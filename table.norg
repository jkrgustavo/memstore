@document.meta
title: Hash Table Implementation
descrtiption: Example implementation of a hash table in C++
@end

@code cpp

template <class elemType>
class hashT {
 public:
    void insert(string key, const elemType& rec, int &collisions);
    void insert(string key, const elemType& rec);
        // Function to insert an item in the hash table. The first
        // parameter specifies the initial hash index of the item to
        // be inserted. The item to be inserted is specified by the
        // parameter rec.
        // Postcondition: If an empty position is found in the hash
        //    table, rec is inserted and the length is incremented by
        //    one; otherwise, an appropriate error message is
        //    displayed.

    void search(string key, const elemType& rec, bool& found) const;
        // Function to determine whether the item specified by the
        // parameter rec is in the hash table. The parameter hashIndex
        // specifies the initial hash index of rec.
        // Postcondition: If rec is found, found is set to true and
        //    hashIndex specifies the position where rec is found;
        //    otherwise, found is set to false.

    void retrieve(string key, elemType& rec) const;
        // Function to retrieve the item at position hashIndex.
        // Postcondition: If the table has an item at position
        //    hashIndex, it is copied into rec.

    void remove(string key, const elemType& rec);
        // Function to remove an item from the hash table.
        // Postcondition: Given the initial hashIndex, if rec is found
        //    in the table it is removed; otherwise, an appropriate
        //    error message is displayed.

    int hashFunc(string name) const ;
  
    hashT(int size = 101);
        // constructor
        // Postcondition: Create the arrays HTTable and indexStatusList;
        //    initialize the array indexStatusList to 0; length = 0;
        //    HTSize = size; and the default array size is 101.

    ~hashT();
        // destructor
        // Postcondition: Array HTable and indexStatusList are deleted.

private:
    elemType* HTable;       // pointer to the hash table
    int *indexStatusList;   // pointer to the array indicating the status of a position in the hash table
    int length;             // number of items in the hash table
    int HTSize;             // maximum size of the hash table
};

template <class elemType>
int hashT<elemType>::hashFunc(string key) const {
    int sum;
    int len;

    sum = 0;
    len = key.length();

    for (int k = 0; k < 20 - len; k++) {
        key = key + ' ';
    }

    for (int k = 0, i = 0; k < 4; k++, i+=5) {
        sum += static_cast<int>(key[i]) * static_cast<int>(key[i]) + static_cast<int>(key[i + 1]);
    }

    int mod = sum % HTSize;
    
    int num_bits = 20;
    int init = (1 << num_bits) - 1;
    int result = (mod & init);
    
    return result;
}

// constructor
template <class elemType>
hashT<elemType>::hashT(int size) {
    assert(size > 0);

    HTable = new elemType[size];
    indexStatusList = new int[size];
    length = 0;
    HTSize = size;

    for (int i = 0; i < size; i++) {
        indexStatusList[i] = 0;
    }
}

template <class elemType>
void hashT<elemType>::insert(string key, const elemType& rec, int &collisions) {
    int probeCount;
    int inc;
    int hashIndex = hashFunc(key);

    collisions = 0;
    probeCount = 0;
    inc = 1;

    if (indexStatusList[hashIndex] == 1) {
        collisions++; 
    }
    while (indexStatusList[hashIndex] == 1 && HTable[hashIndex] != rec && probeCount < HTSize / 2) {
        probeCount++;
        hashIndex = (hashIndex + inc) % HTSize;
        inc = inc + 2;   
    }

    if (indexStatusList[hashIndex] != 1) {
        HTable[hashIndex] = rec;
        indexStatusList[hashIndex] = 1;
        length++;
    } else if (HTable[hashIndex] == rec) {
        cerr << "Error: No duplicates are allowed" << endl;
    } else {
        cerr << "Error: The table is full. Unable to resolve the collision" << endl;
    }
}

template <class elemType>
void hashT<elemType>::insert(string key, const elemType& rec) {
    int dummyCount;

    insert(key, rec, dummyCount);
}

template <class elemType>
void hashT<elemType>::search(string key, const elemType& rec, bool& found) const {
    int pCount = 0;
    int inc = 1;
    found = false;    
    int hashIndex = hashFunc(key);

    while (indexStatusList[hashIndex] != 0 && HTable[hashIndex] != rec && pCount < HTSize / 2) {
        pCount++;
        hashIndex = (hashIndex + inc) % HTSize;
        inc = inc + 2;
    }

    if (indexStatusList[hashIndex] == 1 && HTable[hashIndex] == rec) {
        found = true;
    }
}

template <class elemType>
void hashT<elemType>::retrieve(string key, elemType& rec) const {
    int hashIndex = hashFunc(key);
    
    if (indexStatusList[hashIndex] == 1) {
        rec = HTable[hashIndex];
    }
}

template <class elemType>
void hashT<elemType>::remove(string key, const elemType& rec) {
    bool found;
    int hashIndex = hashFunc(key);

    search(key, rec, found);

    if (found) {
        indexStatusList[hashIndex] = -1;
        length--;
    } else {
         cerr << "The item to be deleted is not in the list." << endl;
    }
}

// destructor
template <class elemType>
hashT<elemType>::~hashT() {
    delete[] HTable;
    delete[] indexStatusList;
}

@end
